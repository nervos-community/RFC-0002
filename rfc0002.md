# Nervos CKB: A Common Knowledge Base for Crypto-Economy 加密经济的共同知识库

## **Abstract 概述**
Nervos is a layered crypto-economy network. Nervos separates the infrastructure of a crypto-economy into two layers: a verification layer (layer 1) that serves as a trust root and smart custodian, and a generation layer (layer 2) for high-performance transactions and privacy protection.
This document provides an overview of the Nervos Common Knowledge Base (CKB), a public permissionless blockchain and layer 1 of Nervos. CKB generates trust and extends this trust to upper layers, making Nervos a trust network. It's also the value store of the Nervos network, providing public, secure and censorship-resistant custody services for assets, identities and other common knowledge created in the network.
  <br />Nervos是一个分层的加密经济网络。Nervos将加密经济的基础设施分做两层: 验证层(Layer1)能够作为信任的根源以及智能监管；生成层(Layer2)则是作为高速交易以及隐私保护。
这份文件提供一个关于Nervos Common Knowledge Base(CKB)的公链以及Narvos的Layer1概述。CKB产生了信任，并且将这份信任延伸至更上层，使得Nervos产生一个信任的网络。这也是Nervos网络中的价值商店，提供公开、安全，以及为在网络中所创建的资产、身份和其他公共知识创造了抗审查的托管服务。

## **Contents 内容**
1.	Motivation 动机
2.	Overview 概述
3.	Consensus 共识
4.	Programming Model 编程模型
  <br />- State Generation and Verification 状态生成与验证
  <br />- Cell 细胞
  <br />- VM 虚拟机
  <br />- Transaction 交易
5.	Economic Model 经济模型
6.	Network 网络
7.	Summary 总结
8.	References 文献
9.	Appendix 附录


## **1.Motivation 动机**

We want a peer-to-peer crypto-economy network.
In such a network, people can not only collaborate but also have incentives to do so. We need the ability to define, issue, transfer, and own assets in a peer-to-peer network to create such incentives. Blockchain technology brings us the last piece of the puzzle.
Bitcoin[1] was the first public permissionless blockchain, designed to be used solely as peer-to-peer cash. Ethereum[2] extends the use case of blockchain to create a general purpose trust computing platform on which people have built all kinds of decentralized applications. The booming applications on the Bitcoin and Ethereum networks have proven the concept of the future crypto-economy. However, these networks also suffer from the notorious scalability problem, their transaction processing capability cannot scale with the number of participants in the network, which severely limits their potential.
  <br />我们想要一个点对点的加密经济网络。
在这个网络中，人们不只可以共同协作，也可以因此得到激励。我们必须有能力在这个点对点的网络中去定义、发行、交易以及拥有自己的资产，以创造这样的激励。区块链技术带来了最后一块的拼图。
比特币是第一个被设计来单用于点对点现金的公有认许制区块链。以太坊则延伸了区块链的使用场景，创造一个人们能够建立各种去中心化应用的通用信任计算平台。在比特币和以太坊网络中激增的应用，也已经证明了未来的加密经济的概念。然而，这样的网络也苦于声名狼藉的扩展性问题，他们的事务处理能力，并没有办法因为在网络中的参与者数量增加而规模化，这严重的限制了他们的潜力。


The blockchain community has proposed many scalability solutions in recent years. In general, we can divide these solutions into two categories, on-chain scaling and off-chain scaling. On-chain scaling solutions are those that try to scale at the same layer where consensus runs. The consensus process is the core of a blockchain protocol, in which nodes exchange network messages and reach agreement eventually. A consensus is slow almost by definition, because message exchange on a public and open network is slow and uncertain, nodes must wait and retry to reach agreement in the consensus process. 
  <br />区块链社群在最近已经提议了各种扩展性解决方案。一般而言，我们可以将这些解决方案分成两种，链上的扩容和链下的扩容。链上扩容的解决方案即是希望试着在共识运行的同一层中，去增大该层区块链的容量。共识的进程是区块链协议的核心，也就是节点们交换讯息，并且最终达成协议。从定义上来看，共识几乎是缓慢的，因为在公开且开放的网络中的讯息交换是缓慢且不确定的，节点必须等待且重试以在共识的进程中达成协议。


To scale at this layer, we can either "scale up" by increasing the processing ability and network bandwidth of nodes (but sacrifice decentralization due to high hardware and infrastructure costs), or "scale out" by sharding. The idea of sharding is to divide nodes into many small "shards", and ask each shard to process only a fraction of network transactions. Sharding is widely adopted by Internet giants, as they face the same scalability issues when serving millions of users. However, sharding is well known for the complexity of shard coordination and cross-shard transactions, which even in a trusted environment, leads to performance degradation as the number of shards grows.
  <br />为了要达到此层的扩展，我们可以藉由增加进程的能力以及节点网络带宽而增加扩展性(但是牺牲去中心化，因为硬件和基础设施的成本)；或者也可以透过分片的方式向外扩展。分片的概念是将节点分成很多个小分片，并要求每个分片只处理一部分的网络交易。分片的概念已经被许多互联网巨头所使用，由其当他们服务数百万名使用者，并同样面临到扩展性的问题时。然而，分片以分片协调(shard coordination)和跨片交易( cross-shard transactions)的复杂性闻名，即使在可信任的环境中，当分片数量成长的时候，也会导致其性能降低。


In contrast, off-chain scaling solutions acknowledge the inherent complexity of the consensus process. They recognize that consensus within different scopes incur different costs, and the global consensus created by a public permissionless blockchain is the most expensive consensus. While it is hard to scale a global consensus, we can use it wisely. Most transactions between two or more parties don’t need to be known by every node in the network, except when they are securely settled; in other words, when users want to turn their transactions into common knowledge of the network. This network scales by offloading most of the work to upper layers, with no limit on scalability. Processing transactions off-chain also brings additional benefits, such as lower latency and higher privacy.
  <br />对比而言，链下扩容解决方案承认了共识的进程要协商一致，具有与生俱来的复杂性。他们认知到了不同范围内的共识会导致不同的成本，而一个公共无许可制的区块链全球共识则是最昂贵的成本。然而我们很难扩容一个全球共识，但我们可以智慧的使用他。多数在两者或多者之间的交易，并不需要每个网络中的节点都知道，除了他们(的状态)已经安定下来的时候；换句话说，当用户想要将他们的交易转到网络的公共数据库中。这个网络会将大部分的工作转移到上层，所以没有负载的问题。处理链下交易也带来额外的好处，就是低延迟以及高隐私性。


While we agree with the general ideas of off-chain scaling, we have found that there is no existing blockchain designed for it. For example, though the lightning network is one of the earliest explorations in off-chain scaling, it has taken years to launch its testnet and is still far from mass-adoption due to the limitations of the underlying Bitcoin protocol. Ethereum provides powerful programming ability, but its computation-oriented economic model doesn’t fit well with off-chain scaling. Because off-chain participants handle most of the computation, what is required is a blockchain that can keep their assets in secure custody and move assets according to the final state of their computation. The computation-oriented design of Ethereum also makes it difficult to execute transactions in parallel, which is an impediment to scalability.
  <br />虽然我们都同意概略的链下扩容思想，但我们却发现目前没有既存的区块链为他而设计。例如，虽然闪电网络是最早的链下扩容探索，但经过了数年去发行测试网后，却因为比特币底层协议的限制，所以仍然离被大量使用有一段距离。以太坊提供强效的编程能力，但他的计算导向的经济模型却不适合链下扩容。因为链下参与者必须负责大部分的计算，这必须要区块链确保他的资产被安全的托管，并且根据他们所计算的最终状态被移转。以计算为导向的以太坊设计，使得平行的执行交易变得很困难，也使得扩容变得很困难。


The economic models of current blockchains also face challenges. With more users and applications moving to blockchain platforms, the amount of data stored on blockchains also increases. Current blockchain solutions are concerned more with the cost of consensus and computation, and allow a user to pay once and have their data occupy full nodes’ storage forever. Cryptocurrency prices also are highly volatile, and users may find it difficult to pay high transaction fees as the price of a cryptocurrency increases.
We propose Nervos CKB, a public permissionless blockchain designed for a layered crypto-economy network.
  <br />最近的区块链经济模型也面临挑战。随着许多使用者和应用者迁移到区块链平台，储存在区块链上的数据总数也在增加。最近的区块链解决方案更关注在共识和计算的成本，而且允许使用者只须付一次的费用就能够永久的在全节点上存储资料。加密货币的价格也非常地不稳定，当加密货币价格上涨时，用户可能因此会难以负担高额的手续费。我们推出Nervos CKB，一个为分层的加密经济网络所设计的公共无许可制的区块链。


## **2.Overview 概览**
Nervos CKB (Common Knowledge Base) is a layer 1 blockchain, a decentralized and secure layer that provides common knowledge custody for the network. Common knowledge refers to states that are verified by global consensus. Crypto-assets are an example of common knowledge.
  <br />Nervos CKB(Common Knowledge Base，公共知识库)是一个layer1的区块链，一个区中心化的安全层，提供给网络中的公共知识托管服务。公共知识是指经过全球共识验证的状态。加密资产是一个公共数据库的例子。


In Nervos, the CKB and all layer 2 protocols work together to serve the crypto-economy. CKB (or layer 1) is where state is stored and defined, and layer 2 is the generation layer (or computation layer, these two terms are interchangeable) that processes most transactions and generates new states. Layer 2 participants submit newly generated states to the CKB eventually at the time they deem necessary. If those states pass the corresponding verification performed by nodes in a global network, the CKB stores them in a peer-to-peer node securely.
  <br />在Nervos中，CKB和所有的layer2协议共同运作，以为加密经济服务。CKB(或者说layer1)是状态被存储以及定义的地方，而layer2则是处理大多数交易以及生成新状态的生成层(或者说计算层，这两个名词会一直被替换)。Layer2参与者最终会在他们觉得时间已经到了的时候,提交一个新的生成状态到CKB。如果这些状态通过全局网络中的节点验证过，CKB会将他安全的储存到一个点对点的节点中。

The layered architecture separates state and computation, providing each layer more flexibility and scalability. For example, blockchains on the generation layer (layer 2) may use different consensus algorithms. CKB is the lowest layer with the broadest consensus and provides the most secure consensus in the Nervos network. However, different applications might prefer different consensus scopes and forcing all applications to use CKB’s consensus would be inefficient. Applications can choose the appropriate generation methods based on their particular needs. The only time these applications will need to submit states to CKB for broader agreement is when they need to make these states common knowledge that has been verified by the CKB’s global consensus.
  <br />分层架构分离了状态及运算，分别提供彼此之间更有弹性以及可扩容性。例如，在区块链的生成层(layer2)上就可以使用不同的共识算法。CKB是一个搭载广播共识以及提供Nervos网络中最安全共识的最基础层次。然而，不同的应用会偏好不同的共识范围，而且强制所有的应用都采用CKB共识也是没有效率的。应用可以基于它们的需求选择合适的生成办法。只有当他们需要将这些状态变成经过CKB全球节点认证共识的共同知识时，这些应用才必须提交状态给CKB，以达成更广泛的协议。


Possible state generation methods include (but are not limited to) the following:
  <br />可能的状态生成方法包含但不限于下面几种
* 	Local generators on the client: Generators run directly on the client’s devices. Developers can implement the generator in any programming language.
* 	客户端上的本地生成器:生成者直接运行他们的客户端装置。开发者可以使用任何一种编程语言来配置生成器。

* 	Web services: Users may use traditional web services to generate new states. All current web services may work with CKB in this way to gain more trust and liquidity for the generated states. For example, game companies may define in-game items as assets in CKB, the game itself functions as a web service that generates game data, which is then verified and stored in CKB.
* 	网络服务:用户可能会使用传统的网络服务来生成新的状态。全部最近的网络服务可能会和CKB共同来运作，并以这种方式来为生成的状态促进更多的信任和流动性。例如，游戏公司可定义游戏中的物品是CKB中的资产，而游戏本身就是一个网络服务，且他会生成可以被验证并且储存在CKB中的游戏资料。

* 	State channels: Two or more users may use peer-to-peer communication to generate new states.
* 	状态通道:两者或者更多的使用者，可能会使用点对点的通讯服务来生成新状态。

* 	Generation chains: A generation chain is a blockchain that generates new states and stores them in CKB. Generation chains may be permissionless blockchains or permissioned blockchains. In each generation chain, nodes reach consensus in smaller scopes, providing better privacy and performance.
* 	生成链(Generation chains):一个生成链是一个可以生成新状态并且储存他们在CKB中的区块链。生成链可以是无默许制或者默许制的区块链。在个别的生成链中，节点可以在更小范围内达成共识，并提供更好的隐私和性能。
 
![](https://i.imgur.com/CmjICLP.png)
 Figure 1. Layered Architecture

CKB consists of a Proof-of-Work based consensus, a RISC-V instruction set based virtual machine, a state model based on cells, a state-oriented economic model, and a peer-to-peer network. The Proof-of-Work based consensus makes the CKB a public and censorship-resistant service. The combination of CKB VM and the Cell model creates a stateful Turing-complete programming model for developers, making state generation (or layer 2) on CKB practical. The CKB economic model is designed for common knowledge custody and long-term sustainability. The CKB peer-to-peer network provides secure and optimal communication between different types of nodes.
  <br />CKB是个由工作量证明(POW)组成的共识，是一个基于RISC-V指令系统的虚拟机，一个基于cells的状态模型，一个状态导向的经济模型，以及一个点对点的网络。以工作量证明为基础的共识使得CKB成为一个公开且抗审查的服务。结合CKB虚拟机还有Cell模型，为开发者创造一个有状态的图灵完备编程模型。CKB的经济模型是为了公共的知识托管还有长期的永续性而设计。CKB的点对点网络提供给不同型态的节点间一个安全而且最优化的通讯方式。

## **3.Consensus 共识**
CKB consensus is an improved Nakamoto consensus based on Proof-of-Work, that aims to achieve openness, correctness and high performance in distributed environments with network delay and Byzantine node faults.
Permissionless blockchains run in open networks where nodes can join and exit freely, with no liveness assumptions. These are severe problems for traditional BFT consensus algorithms to solve. Satoshi Nakamoto introduced economic incentives and probabilistic consensus to solve these problems. Nakamoto consensus in Bitcoin uses blocks as votes, which takes longer (up to 10 minutes to an hour) to confirm transactions and leads to an inferior user experience.
  <br />CKB共识是一个基于工作量证明的改善版中本聪共识，目标是在具有网络延迟和拜占庭节点错误的分布式环境中达到开放性，正确性以及高性能。无认许制的区块链运作在一个开放的网络中，在这里节点可以随意的加入与退出，并且不具有活泼性假设。传统的拜占庭容错共识算法有严重且还待解决的问题。中本聪引进了经济激励以及机率性质的共识来解决这个问题。中本聪共识在区块链世界中使用区块作为投票，须要花长时间(10分钟到一小时的时间)来确认交易，这也导致了较差的用户体验。

CKB consensus is a Nakamoto consensus variant, which means it allows nodes to join and exit the network freely. Every node can participate in the consensus process either by mining (running a specific algorithm to find the Proof-of-Work) to produce new blocks, or by verifying new blocks are valid. CKB uses an ASIC-neutral Proof-of-Work function, with the goals of distributing tokens as evenly as possible and making the network as secure as possible.
Correctness includes eventual consistency, availability, and fairness. Eventual consistency guarantees every node sees an identical copy of state. Availability makes sure the network responds to users’ requests within a reasonable time. Fairness ensures mining nodes get fair returns for their efforts to keep the network functioning securely.
  <br />CKB共识是一个基于中本聪共识的变化体，也就是代表他允许节点自由的加入与退出。每个节点既可以透过挖矿(运行一个特定的算法来达到工作量证明)来制造新区块，也可以透过验证区块有效性的方式来参与共识。CKB使用了ASIC中立的工作量证明型态，目标是尽可能均衡的分散代币，以及尽可能地达到网络安全。正确性包含最终的一致性，可用性还有公平性。最终的一致性保证每个节点都能看到状态相同的一致副本。可用性则确保网络可以在合理的时间内响应用户的需求。公平性则确保挖矿的节点可以让他们的付出得到公平的回报，以确保网络的功能安全。

High performance includes transaction latency, the time between the submission of a request and the confirmation of its execution results, and transaction throughput, the number of transactions the system is capable of processing per second. Both of these measures depend on block time, which is the average time between two consecutive blocks.
Please check the CKB Consensus Paper for more details.
  <br />高性能包含交易延迟性，提交请求到确认执行结果的时间，还有交易吞吐量，也就是每秒整个系统能够处理的交易数量。这些计算依赖于区块时间，也就是连续两个区块出呙的平均时间。

如果想知道更多细节请参阅CKB的共识白皮书。

## **4.Programming Model 编程模型**
CKB provides a stateful Turing-complete programming model based on CKB VM and cell model.
  <br />CKB提供了基于CKB 虚拟机和Cell模型的有状态图灵完备的编程模型。
	

| | Bitcoin | Ethereum | CKB |
|-|---------|----------|------------|
|Instruction Set|Script|EVM|RISC-V|
|Cryptographic Primitive|Opcode|Precompile|Assembly|
|Stateful|No|Yes|Yes|
|State Type|Ledger|General|General|
|State Model|UTXO|Account|Cell|
|State Verification|On-chain|On-chain|On-chain|
|State Generation|Off-chain|On-chain|Off-chain|

The CKB programming model consists of three parts:
* state generation (off-chain) 
* state verification (CKB VM)
* state storage (Cell model)

在CKB编程模型中包含了三个部分
* 状态生成(鏈下)
* 状态验证(CKB 虚拟机)
* 状态存储(Cell模型)

In this model, decentralized application logic is split into two parts (generation and verification), running in different places. State generation logic runs off-chain on the client side; new states are packaged into transactions and broadcasted to the entire network. CKB transactions have an inputs/outputs based structure like Bitcoin. Transaction inputs are references to previous outputs, along with proofs to unlock them. The client includes generated new states as transaction outputs, which are called cells in CKB. Cells are the primary state storage units in CKB and are assets owned by users that must follow associated application logic specified by scripts. CKB VM executes these scripts and verifies proofs included in inputs to make sure the user is permitted to use referenced cells and the state transition is valid under specified application logic. In this way, all nodes in the network verify that new states are valid and keep these states in custody.
  <br />在此模型中，去中心化的应用逻辑分成两个部分(生成和验证)，并且运行在不同的地方。状态生成的逻辑运行在链下的客户端；新状态被打包到交易中并且被广播到全网。CKB交易已经有一个像比特币一样，以输入/输出为基础的结构。交易输入以上一个交易输出为依据，并以此为证去解锁他们。客户端生成包含如交易输出这种新状态，在CKB中也称作Cell。Cell是CKB中最基础的状态存储单位，并且是用户所拥有的资产，必须遵循指定脚本的相关应用逻辑。CKB虚拟机执行这些脚本，并且验证证明输入以确保使用者被允许使用有依据的Cell，以及状态交易在特定应用逻辑下是有效的。在这样的情况下，所有网络中的节点都验证新状态是有效的，并且使新状态被保管起来。

State in CKB is a first-class citizen, states are included in transactions and blocks and synchronized directly among nodes. Although the programming model is stateful, scripts running in CKB VM are pure functions with no internal state, which makes CKB scripts deterministic, conducive to parallel execution, and easy to compose.
  <br />状态在CKB中是一级公民，状态包含交易和区块，以及其他同步的节点。虽然编程模型是有状态的，运行在CKB中的脚本是没有任何的状态，只有纯粹的功能，这可以让CKB脚本更有确定性，有利于平行执行，并且易于组合。


### **4.1 State Generation and Verification 状态生成与验证**

Decentralized applications on Nervos separate the generation and verification of state. While these processes occur in different places, CKB provides the additional flexibility to utilize different algorithms for state generation and verification.
  <br />在Nervos的去中心化应用中把状态的生成和验证进行分离。当这些进程发生在不同地方时，CKB提供了额外的灵活性以利用不同的算法来进行状态的生成和验证。

Utilizing the same algorithm on both generation and verification sides is a straightforward choice that works for general problems. In this model, the same algorithm has two implementations, one that runs off-chain in any execution environment targeted by the application, and the other one runs on-chain in CKB VM. New states are generated off-chain with this algorithm (based on previous states and user inputs), packaged as a transaction, and then broadcasted to the network. CKB nodes run this same algorithm on-chain, provide it the same previous states and user inputs, and then verify the result matches the transaction-specified outputs.
  <br />在状态生成和验证这两侧同时使用同种算法，是个用来处理一般问题的简单方法。在这个模型当中，同样的算法有两种配置，一种是运行在链下任何被应用程序目标的执行环境，另一种则是运行在链上的CKB虚拟机中。新状态透过这个算法生成(基于先前的状态和用户输入)，封包成一个交易，并且将他广播到网络中，CKB节点会在链上运行这个算法，提供和先前一样的状态和使用者输入，并去验证结果符不符合以及是否匹配特定的交易输出。

There are several advantages to this separation of state generation and validation:
  <br />这里有几个分离状态生成以及状态验证的优点:

* Deterministic transactions: Certainty of transaction execution is one of the core pursuits of decentralized applications. If transactions include only user input and new states are the result of computation on nodes (as seen in Ethereum), the transaction creator cannot be certain about the on-chain computation context, which may lead to unexpected results. In CKB, users generate new states on the client side. They can confirm the new states before broadcasting their state transition to the network. The transaction outcome is certain: either the transaction passes on-chain verification and the new state is accepted, or the transaction is deemed invalid and no state change is made to CKB (Figure 1).

* 确定的交易(Deterministic transaction):交易(事务)执行的确定性是去中心化应用的其中一个核心要求。如果交易只包含用户输入，而且新的状态是节点上的运算结果(如我们在以太坊上面看到的)，交易创造者并不能确定链上的计算内容，这可能会导致易想不到的结果。在CKB中，使用者生成新状态在客户端。他们可以在广播交易到全网前确认状态。无论交易是否能够通过验证，并且让新状态被接受，还是被认定是无效的交易并且没有新状态在CKB上，交易的结果都是确定的。


* Parallelism: If transactions only include user inputs and new states are generated by nodes, then nodes will not know what state is going to be accessed by the verification process, and cannot determine dependencies between transactions. In CKB, because transactions explicitly include previous states and new states, nodes can see dependencies between transactions prior to verification, and can process transactions in parallel.
* 平行处理(Parallelism):如果交易只包含用户输入而新状态只被节点所产生，那么节点不会知道什么状态将被验证的进程所接受，并且不能决定交易的依存(顺序)关系。在CKB中，因为交易明确的包含先前的状态和新状态，节点可以在验证前看到交易间的依存关系，并且可以平行的处理交易。

* Higher resource utilization: As application logic is split and run in different places, the network can distribute computational workload more evenly across nodes and clients, and thus utilize system resources more efficiently.
* 高度的资源使用:当应用程序的逻辑被分离并且在不同地方运行时，网络可以在节点和客户端之间更加公平的分配运算资源的工作量，并因此更加效率的使用系统资源。

* Flexible state generation: Even when the same algorithms are used, developers can implement generation and validation in different ways. On the client side there is the flexibility to choose the programming language that provides for better performance and fast development.
* 弹性的状态生成:即使当使用相同的算法，开发者可以用不同的方式来实现生成和验证。在客户端那边是可以弹性的选择提供更高性能以及更快速开发的程序语言。

In some scenarios, state verification can utilize a different (but associated) algorithm that is much more efficient than the one used for state generation. The most typical example is seen in Bitcoin transactions: Bitcoin transaction construction consists mainly of a searching process to identify appropriate UTXOs to use, while verification is the addition of numbers and simple comparison. Other interesting examples include sorting and searching algorithms: the computational complexity for quicksort, one of the best sorting algorithms for the average case, is O(Nlog(N)), but the algorithm to verify the result is just O(N). Searching for the index of an element in a sorted array is O(log(N)) with binary search, but its verification only takes O(1). The more complex the business rules, the higher probability that there can be asymmetric generation and validation algorithms with differing computational complexity.
  <br />在某些场景中，状态验证可以使用不同(但相关)的算法，这种算法会比使用状态生成时用的算法还高效。比特币交易可以被视为最典型的案例:比特币交易构造主要由搜寻识别可用UTXOs的过程所构成，然而验证则是数字加法和简单的比较法。其他有趣的案例包含排序和搜索算法:快速排序的计算复杂度，平均情况下最好的排序算法之一，是O(Nlog(N))，但算法要验证结果却只要用O(N)。用二分法搜索排序数组中元素的索引是O(log(N))，但其验证算法只需要是O(1)。越复杂的商业规则，就有越高的可能性存在具有不同的计算复杂度的非对称的生成和验证验算法。

System throughput can be improved by utlizing asymmetry between state generation and validation. Moving details of computation to the client side is also valuable for algorithm protection and privacy. With the advancement of technologies such as zero-knowledge proofs, we may find efficient generation and verification solutions to general problems, and CKB is a natural fit for these types of solutions.
  <br />系统吞吐量可以藉由状态生成和验证之间的非对称性去增进。将计算细节移到客户端对于算法的保护与隐私也是有价值的。随着如零知识证明等等技术进步，我们也许会发现更有效率的生成与验证的一般问题解决方案，而且CKB也是自然适合这些类型的解决方案。

We refer to programs that generate new states and create new cells as Generators. Generators run locally on the client side (off-chain). They utilize user input and existing cells as program inputs, to create new cells with new states as outputs. The inputs that Generators use and the outputs they produce together form a transaction.
  <br />我们将涉及生成新状态以及创造新Cells的程序称为生成器(Generators)。生成器运行在本地的客户端上(链下的)。它们使用用户自己的输入和既有的cell作为程序的输入，以创造新的cells作为输出。生成器使用的输入以及他们制造的输出一起构造成一个交易。
![](https://i.imgur.com/ITa9cLW.png)

Figure 2. Separation of state generation and verification
  <br />图二、状态生成和验证的分离


### **4.2 Cell**
Cells are the primary state units in CKB, within them users can include arbitrary states. A cell has the following fields:
* `capacity` – Size limit of the cell. A cell’s size is the total number of bytes of all fields contained in it.
* `data` – State data stored in this cell. It could be empty, however the total bytes used by a cell (including data), must always be less than or equal to its capacity.
* `type`: State verification script.
* `lock`: Script that represents the ownership of the cell. Owners of cells can transfer cells to others.

Cells是CKB中基本的状态单元，用户可以在其中包含任意的状态。一个cell由以下几个字段构成:
* `容量(capacity)`:细胞的大小限制。一个Cell的大小是包含所有字段的总字节数
* `资料(data)`:状态数据储存在cell当中。他可以是空的，但是被Cell所使用的总字结数必须总是小于等于cell的容量
* `型态(type)`: 状态验证的脚本
* `上锁(lock)`: 一个代表cell的所有权的脚本。

A cell is an immutable object, no one can modify it after creation. Every cell can only be used once, it cannot be used as input for two different transactions. Cell ‘updates’ mark previous cells as history and create new cells with the same capacity to replace them. By constructing and sending transactions, users provide new cells with new states in them and invalidate previous cells that store old states atomically. The set of all current (or live) cells represents the latest version of all common knowledge in CKB, and the set of history (or dead) cells represents all historical versions of common knowledge.
  <br />一个Cell就是一个不可修改的对象，没有人可以在创造出来之后去修改他。所有的cell都只能被使用一次，他不能做为两个不同交易的输入。Cell将先前的cel1标记为为历史来更新cell，而新的cell会有同样的容量并且取代他们。藉由建构以及传送交易，用户提供具有新状态的新cells，并且原子般使得储存旧状态的cells失效。所有最近(或者说「活」的)cells的集合代表CKB中最新的共同知识，而且历史的(或者说「死」的)集合代表所有共同知识的历史版本。

CKB allows users to transfer a cell’s capacity all at once, or transfer only a fraction of a cell’s capacity, which would in turn lead to more cells being created (e.g., a cell with capacity=10 can become two cells with capacity=5).
  <br />CKB允许使用者一次性的传输全部cell的容量，或者只传输一部份的容量，而这会导致更多的cells被创建(例如，一个cell有10个容量，可以变成两个有5的容量的cell)

Two kinds of scripts (type and lock) are executed in CKB VM. CKB VM executes the type script when a cell is created in a transaction output, to guarantee the state in the cell is valid under specific rules. CKB VM executes the lock script, taking proofs as arguments, when the cell is referenced by a transaction input, to make sure the user has appropriate permissions to update or transfer the cell. If the execution of the lock script returns true, the user is allowed to transfer the cell or update its data according to validation rules that are specified by the type script.
  <br />有两种脚本(type和lock)会被CKB虚拟机执行。CKB虚拟机执行type脚本，当一个cell在交易输出被创造的时候，以保证细胞中的状态在脚本的规则下是有效的。CKB的虚拟机会执行lock的脚本，以证明作为参数，当cell被交易输入引用时，为了要确保使用者已经有适当的权限来更新或者传输cell。如果lock脚本的执行返回true，使用者会被允许传输cell，或者依据类型脚本所限定的验证规则来上传他们的数据

This type and lock script pair allows all kinds of possibilities, for example:
* Upgradable cryptography – Anyone can deploy useful cryptography libraries written in languages such as C or C++ and use them in type and lock scripts. In CKB VM, there are no hardcoded cryptographic primitives, users are free to choose any cryptographic signature scheme they’d like to use to sign transactions.
* Multisig – Users can easily create M-of-N multisig or more complex lock scripts.
* Lending – Cell owners can lend cells for others to use while still maintaining their ownership of the cells.

type和lock的脚本对允许各种可能性，例如
* 升级的加密算法(Upgradable cryptography)-任何人可以部署以C或C++语言写成的有用的加密函式库，并且在type和lock脚本中使用他们。在CKB的虚拟机中，这里没有写死( hardcoded)的加密基本体(cryptographic primitives)，使用者可以自由的选择任何一种他们想用来签署交易的加密签名方式。
* 多重签名(Multisig)使用者可以轻易地创造出N个M的多重签名或者更复杂的lock脚本
* 借贷:cell的拥有者可以借出cells给其他人使用并同时维持cells的所有权。

The Cell model is a more generic state model compared to the UTXO or Account model. Both the UTXO and the Account model can express relationships between assets and their owners. The UTXO model defines ownership of assets (with the lock script), while the Account model defines ownership of assets by owner (with the account balance). The UTXO model makes the ledger history more clear, but its lack of generic state storage makes its already inexpressive scripts harder to use. The Account model is easy to understand and can support authorizations and identities well, but it presents challenges to processing transactions in parallel. The Cell model with lock and type scripts takes the best of both models to provide a more generic state model.
  <br />和UTXO或者Account相比，Cell模型是更加一般化的状态模型。UTXO和Account模型都能表达出资产与拥有者的关系。UTXO模型定义资产所有权(用lock脚本)，同时Account模型也透过所有者去定义资产所有权(用账户余额)。UTXO模型使得帐户历史变得更清楚，但是他缺乏通用状态，这使得他原本就缺乏表现力的脚本更加难以被使用。Account模型非常容易理解，并且可以非常好的支持授权以及身分识别，但这也对于平行处理交易(事物)提出了挑战。拥有type和lock脚本的Cell模型取这两个模型最好的点来提供一个更通用的状态模型。

### **4.3 VM 虚拟机**
CKB VM is a RISC-V instruction set based VM for executing type and lock scripts. It uses only standard RISC-V instructions, to maintain a standard compliant RISC-V software implementation which can embrace the broadest industrial support. CKB implements cryptographic primitives as ordinary assembly running on its VM, instead of customized instructions. It supports syscall, by which scripts can read metadata such as current transaction and general blockchain information from CKB. CKB VM defines cycles for each instruction, and provides total cycles executed during transaction verification to help miners determine transaction fees.
  <br />CKB的虚拟机是一个为了用来执行type和lock脚本，且基于RISC-V指令集的虚拟机。他只使用标准的RISC-V 指令集，以维护一个符合RISC-V标准的软件实现，他也能够涵盖最宽广的业界支持。CKB履行了加密基本体以作为运行在虚拟机上的普通程序集(assembly) ，而不是自定义的指令。他支持系统调用，也就是脚本可以读取如CKB上的近期交易或者一般的区块链信息等元数据(metadata)。CKB虚拟机定义了每条指令的循环，并且提供了执行在交易验证以帮助矿工决定交易手续费的总循环。

Existing blockchains hardcode cryptographic primitives in the protocol. For example, Bitcoin has special cryptographic opcodes such as OP_CHECK*, and Ethereum uses special ‘precompiled’ contracts located at a special address (e.g. 0000000000000000000000000000000000000001) to support cryptographic operations such as ecrecover. To add new cryptographic primitives to these blockchains, we can only soft-fork (as Bitcoin re-uses opcodes to support new primitives) or hard-fork.
  <br />既有的区块链将加密基本体写死在协议当中。例如，比特币有特殊的加密操作码(opcodes)例如 OP_CHECK*，而以太坊则是使用特殊的「预编译」(precompiled)合约存放在一个特殊地址中(例如0000000000000000000000000000000000000001)来支持如ecrecover这种加密操作。为了添加新的加密基本体到这些区块链中，我们只能够过软分叉(例如比特币重新使用opcodes来支持新的基本體)或者硬分叉。

CKB VM is a crypto-agnostic virtual machine. There are no special cryptographic instructions hardcoded in CKB VM. New cryptographic primitives can always be deployed and used by scripts like an ordinary library. Being a RISC-V standard compliant implementation means existing cryptographic libraries written in C or other languages can be easily ported to CKB VM and used by cell scripts. CKB even implements the default hash function and public-key cryptography used in transaction verification this way. Being crypto-agnostic allows decentralized application developers on Nervos to use any new cryptography (such as Schnorr signatures, BLS signatures, and zkSNARKs/zkSTARKs) they’d like without affecting other users, and allows CKB users to keep their assets secure even in the post-quantum era.
  <br />CKB虚拟机是一个与加密无关(crypto-agnostic )的虚拟机。没有任何关于密码学的特殊配置写死在CKB的虚拟机中。新的加密基本体总是能够被脚本部署和使用，就像一个普通的函示库。作为一个符合RISC-V标准的实现，代表以C语言写成的既存加密函式库，或者其他语言可以轻易的被转移到CKB的虚拟机上，并且被cell脚本所使用。CKB甚至可以实现交易验证中的默认哈希函数以及公私钥加密法。作为crypto-agnostic，允许去中心化应用开发者在Nervos上使用任何新的密码学技术(例如 Schnorr signatures, BLS signatures, and zkSNARKs/zkSTARKs)，这将不影响其他使用者，并且让CKB使用者即使在一个后量子时代确保他们的资产安全。

CKB VM chooses a hardware targeting ISA because blockchain is hardware-like software. Though its creation is as easy as software, its upgrade is as difficult as hardware. As an ISA designed for chips, RISC-V is very stable, its core instruction set is implausible to change in the future. The ability to keep compatibility with the ecosystem without the need of a hard-fork is a key feature of a blockchain virtual machine like CKB VM. The simplicity of RISC-V also makes runtime cost modeling easy, which is crucial for transaction fee calculations.
Please check RFC 0003 for more details of CKB VM.
  <br />CKB虚拟机选择一个硬件为目标的ISA，因为区块链是个如硬件般的软件。虽然他的创建像硬件一样容易，但更新却像硬件一样麻烦。作为一个为芯片所设计的ISA， RISC-V非常的稳定，他的核心指令集在未来是不会变的。能够在不需要硬叉的情况下保持与生态系统的兼容性是像CKB VM这样的区块链虚拟机的一个关键特性。RISC-V的简单性也使得运行时间成本的建模便容易，这对于计算交易费用而言相当重要。
如果想知道更多CKB VM的细节请参阅RFC 0003 。

### **4.4 Transaction 交易**
Transactions express state transitions, resulting in cell transfer, update, or both. In a single transaction, users can update data in one or more cells or transfer their cells to other users. All state transitions in the transaction are atomic, they will either all succeed or all fail.
  <br />交易表示状态转换，并且导致cell的转移或更新，或者同时发生。在单一交易中，用户可以在一个到多个cell中上传数据，或者将他们的cell转换给其他使用者。所有交易中的状态转换都是原子性的，他们要嘛都成功，要嘛都失败。

A transaction includes the following:
* deps: Dependent cell set, provides read-only cells required by transaction verification. These must be references to living cells.
* inputs: Cell references and proofs. Cell references point to live cells that are transferred or updated in the transaction. Proofs (e.g., signature) prove that the transaction creator has the permission to transfer or update the referenced cells.
* 	outputs: New cells created in this state transition.

一个交易包含以下内容:
* ` deps`:依赖Cell集合(Dependent cell set)，提供了验证交易所需的只读cell
* `inputs`:Cell的引用( references)和证明。Cell引用针对了激活在交易中被转移或者更新的cell。证明(例如签名)则用来证明交易的创造者已经允许去转移或更新被引用的cell。
* `outputs`:新的cells在这个状态转换的情况下被创造


The design of the CKB cell model and transactions is friendly to light clients. Since all the states are in blocks, block synchronization also accomplishes state synchronization. Light clients only need to synchronize blocks and do not need additional state synchronization or state transition computation. If only events were stored in blocks, full nodes would be required for state synchronization. State synchronization can be difficult across large networks because there are weak incentives to synchronize. This is different from block synchronization, in which miners are incentivized to broadcast blocks as widely as possible. With no need for extra state synchronization, the protocol makes light nodes and full nodes more equal peers, leading to a more robust and decentralized system.
  <br />CKB的cell模型设计和交易设计对于轻客户端( light clients)而言是非常友善的。因为全部的状态都在区块中，区块的同步性也可以完成状态的同步性。轻客户端只需要同步区块而不需要额外的状态同步或状态转换计算。如果只有事件储存在区块中，全节点将会需要状态同步。跨大型网络的状态同步可能会非常困难，因为同步的诱因太过微弱。这和区块同步非常不同，区块同步指的是矿工尽可能的到处广播区块会得到奖励。在不需要额外的状态同步下，协议就可以让轻节点和全节点更加对等，从而建立一个更健壮和更去中心化的系统。
![](https://i.imgur.com/38ubs57.png)

 Figure 3. Transaction Parallelism and Conflict Detection
The deps and inputs in CKB transactions make it easier for nodes to determine transaction dependencies and perform parallel transaction processing (Figure 4). Different types of cells can be mixed and included in a single transaction to achieve atomic operation across types.

## **5. Economic Model 经济模型**
A well-designed economic model should incentivize all participants to contribute to the success of the crypto-economy and maximize the utility of the blockchain.
The CKB economic model is designed to motivate users, developers and node operators to work toward the common goal of common knowledge custody. The subject of the CKB economic model is state instead of computation, by using cell capacity and transaction fees as incentives for stakeholders.
  <br />一个设计良好的经济模型应该奖励所有的参与者来贡献，以达到加密经济的成功以及区块链使用的最大化。CKB的经济模型是设计来激励用户、开发者以及节点操控者一起努力实现托管共同知识的普世目标。CKB的经济模型的主题在状态，而不是计算，他藉由使用cell的容量还有交易手续费来作为给利益关系人的奖励。

### **5.1 State Cost and Cell Capacity 状态成本与Cell容量**
The creation and storage of states on the CKB incur costs. The creation of new states needs to be verified by full nodes (which incur computational costs), and the storage of states requires full nodes to provide disk space on an ongoing basis. Current permissionless blockchains only charge one-time transaction fees, but allow states to be stored on all full nodes, occupying storage space indefinitely.
  <br />CKB上的状态的创造和储存会产生成本。新状态的创造需要被全节点验证(会需要计算成本)，而状态的存储也会需要全节点不断的提供磁盘空间。最近的非特许区块链只收取一次的交易手续费，但却允许状态储存在全节点上，永久地占据存储空间。

In CKB, cells are basic storage units of state. A cell owner can use the cell to store state himself or lend it out to others. Because a cell’s capacity can only be utilized by one user at a time, an owner utilizing the capacity himself would give up the opportunity to earn interest by lending the capacity out (either to CKB or to other users). With this opportunity cost, users pay for storage with a cost that is proportional to both space and time – the larger the capacity and the longer time they occupy it, the higher opportunity cost they incur. The advantage of CKB’s implicit state cost model, when compared to an upfront payment model (such as storage rent discussed in the Ethereum community), is that it avoids the problem that upfront payments could be used up and the system would have to recycle the state and break any applications or contracts depend on it.
  <br />在CKB中，Cells是最基本的状态储存单位。一个cell的拥有者可以使用Cell来为他自己储存状态，或者出借给其他人。因为一个cell的容量只能在一个时间点被一个人使用，一个拥有者使用了其容量完了以后将会失去掉透过出借容量来赚取利益的机会(要嘛可以是CKB，也可以是其他使用者)。在有这个机会成本下，使用者为了存储空间所付出的成本会同时与时间和空间成正比--容量越大、占用时间越长，他们要付出的机会成本就越高。CKB的隐含状态成本的模型和预付的模型相比(例如在以太坊小区被讨论的存储租金)可以避免预付金被用光，然后系统必须回收状态以及破坏任何依存于他的合约或者应用。

Cell metadata (capacity, type and lock) are states, which will occupy users’ cell capacity and incur a state cost as well. This meta cost would incentivize users to create fewer cells when possible, increasing capacity efficiency.
  <br />Cell的元数据(capacity, type and lock)是状态，也就是会占据用户的Cell容量，并同时引发状态成本。这些元数据成本会激励用户尽可能地来减少Cells的使用，并增加储存效率。


### **5.2 Computation Cost and Transaction Fees 计算成本和交易费用**
Updating a cell’s data or transferring cell ownership incurs transaction fees. Miners can set the transaction fee level that they are willing to accept based on CKB VM cycles used and state changes in transaction verification, allowing the market to determine transaction fees. With the programming model described above, cell owners can also pay transaction fees on behalf of their users.
  <br />更新一个cell的数据或者转移一个cell的所有权都会产生交易费用。矿工可以基于CKB虚拟机的使用循环还有交易验证的状态变化，去设定他们愿意接受的交易费用等级，并允许市场去决定交易费用。透过上述的编程模型，Cell所有者还可以代表用户支付交易费用。

As cell capacity is the only native asset in CKB, it is the most convenient asset users can use to pay transaction fees. However, users can also use any other user-defined assets as long as miners accept them; there is no hard-coded payment method in CKB transactions. This is allowed in CKB because its economic model and native asset do not center on computation, but states. Although cell capacity can be used as a means of paying transaction fees, its primary function is secure common knowledge storage, which can store state and hold it long-term. Payment method competition in the fee market does not compromise its value.
  <br />如同cell容量是唯一在CKB中的天然资产，这也是最便利的资产可供用户用来支付交易手续费。然而，只要能被矿工所接受，用户可以同时使用其他用户自定义的资产；在CKB交易中没有写死的支付方式。这在CKB中是允许的因为经济模型和天然资产并不是计算为核心，而是以状态为核心。虽然Cell的容量可以作为一种支付交易手续费的方法，他的首要功能还是确保共同知识的储存，也就是可以让他储存状态和长期保存。支付方式在手续费市场的竞争并不会损害他的价值。

Restricting the transaction fee payment method to a blockchain’s native asset is a significant obstacle preventing blockchains’ mass adoption. This requires users to acquire native assets before using any of the blockchain’s services, raising the barrier of entry for new users. By allowing cell owners to pay fees on behalf of their users and allowing payment with any user-defined assets, CKB can provide a better experience to users and wider choices of business models for developers.
Please check the Nervos CKB Economic Paper for details of the economic model.
  <br />将交易手续费的支付方法限于区块链的天然资产，是阻碍区块链被大量采用的重大障碍。这需要使用者在使用任何区块链服务前就获得这种天然资产，提升了新进使用者的进入门坎。透过允许cell的拥有者来代表用户支付费用，以及允许用各种用户自定义的资产付费，CKB可以提供一个更好的用户体验以及为开发者带来更广泛的商业模型选择。

请查阅Nervos的CKB经济白皮书来了解更多经济模型的细节。

## **6. Network 网络**
We can categorize CKB nodes into three types:
我们可以将CKB节点分为三类
* Mining Node: They participate in the CKB consensus process. Mining nodes collect new transactions, package them into blocks and produce new blocks when they have found a Proof-of-Work. Mining nodes do not have to store the entire transaction history, only the current cell set.
* 挖矿节点:他们参与CKB共识过程。挖矿节点收集新的交易，封包他们到区块中并且在他们找到工作量证明的时候制造新的区块。挖矿节点并不需要储存全部的交易历史，而只须要储存最近的cell集合。

* Full Node: They verify new blocks and transactions, relay blocks and transactions, and select the chain fork on which they agree. Full nodes are the verifiers of the network.
* 全节点:他们需要验证新区块和交易，依据区块和交易，以及选择他们同意的链上分叉。全节点是网络中的验证者。

* Light Node: They trust full nodes, only subscribe and store a subset of cells that they are concerned with. They use minimal resources. Users increasingly rely on mobile devices and mobile apps to access the Internet, the light node is designed to run on mobile devices.
* 轻节点:他们信任全节点，只有订阅和储存和他们相关的cells的子集。它们使用最小的资源。用户渐渐地依赖行动装置和手机Apps来进入互联网，轻节点就是为移动装置所设计。


Uniform blockchain networks (in which each node has the same role and performs the same function) are currently facing severe challenges. Full nodes validate all blocks and transaction data, requiring minimum external trust, but they incur a higher cost and are inconvenient to run. Light clients trade minimal trust for a substantial cost reduction on transaction verification, leading to a much better user experience. In a mature crypto-economy network, the largest group of nodes would be light nodes, followed by full nodes and mining nodes. Because light nodes depend on full nodes for state and state verification, a large number of light nodes would require a large number of full nodes to serve them. With CKB’s economic model, both computation and storage resources required by a full node can be kept at a reasonable level, and the barriers to running a full node low, leading to a large group of service providers for light nodes and a highly decentralized network.
  <br />一致的区块链网络(在其中每个节点都有相同的角色并表现出同一种功能)最近正面临严酷的挑战。全节点验证所有的区块和事务数据，获取最大的外部信任，但却导致较高的成本和运行上的不便。轻量客户端最小的信任换来大量交易验证的成本降低，进而带来更好的用户体验。在一个成熟的加密经济网络哩，最大的节点群会是轻节点，再来才是全节点和挖矿节点。因为轻节点状态及状态验证方面依赖着全节点，一大群轻节点将会需要一大群全节点为他们服务。利用CKB的经济模型，透过全节点的计算和储存资源都能维持一个合理的层及，并且让运行全节点的障碍降低，导致更大群的轻节点服务供货商以及更高度的去中心化网络。


## **7. Summary 结论**
We envision a layered crypto-economy and CKB is its base layer. CKB is the decentralized trust root of this crypto-economy, it ensures the security of the trustless activities of the upper layers. It’s a common knowledge custody network, in which states are verified by global consensus and stored in a highly available peer-to-peer network. CKB is designed from scratch to meet the needs of a layered architecture, and its design focuses on states rather than computation. In CKB, users and developers can define, issue, transfer and store crypto-assets, they can also create digital identities and utilize these identities in the crypto-economy. Only our imagination is the bounds of its use.
  <br />我们设想了一个分层的加密经济，而CKB是这里的基础层。ckb是这个去中心化的信任根源，他确保了上层的无信任活动的安全性。这是一个共同知识的监管网络，这此的状态可以被全球共识所验证，并且储存在高度可用的对等网络中。ckb是从零开始为了多层架构的需求所设计的，他的设计关注在状态，而非计算。在ckb中，使用者和开发者可以定义、发行、转移和储存加密资产，他们也可以创造数字身分和在加密经济中利用这个身分。只有我们的想象力是使用的边界。

## **8. References 学术引用**
Satoshi Nakamoto, “Bitcoin A Peer-to-Peer Electronic Cash System”, 2008
Vitalik Buterin, “Ethereum A Next-Generation Smart Contract and Decentralized Application Platform”, 2014


## **9. Appendix**
Common Knowledge is the knowledge that’s accepted by everyone in a community. Participants in the community not only accept the knowledge themselves but know that others in the community also accept the knowledge.
  <br />共同知识是一种社区中的所有人都能够接受的知识。社区中的参与者不僅接受知识本身，还知道其他社区中的人也能够接受知识。

In the past, common knowledge was scattered across individual’s minds, and its formation required repeated communication and confirmation. Today, with the advancement of cryptography and distributed ledger technology, algorithms and machines are replacing humans as the medium for the formation and storage of common knowledge. Every piece of data in the blockchain, including digital assets and smart contracts, is a piece of common knowledge.
  <br />在过去，共同知识散落在每个人的心智之中，他的形成需要重复沟通和确认。今天，随着密码学以及去中心化账本技术、算法以及机器等的演进，他们正在取代人们作为「形成和储存共同知识」的媒介。每一条区块链中的数据，包含数字资产和智能合约，都是共同知识。

Blockchains are common knowledge bases. Participating in a blockchain network implies accepting and helping validate the common knowledge contained in it. Blockchains store transactions with their proofs, users can trust the validity of these transactions and know other users trust it too.
  <br />区块链是共同知识库。参与在区块链之中的网络暗示了接受以及帮助验证其中所含的共同知识。区块链透过证明储存交易(事务)，用户信任这些交易的有效性并且知道其他人也信任他。

The various ways in which the knowledge on which people base their plan is communicated to them is the crucial problem for any theory explaining the economic process, and the problem of what is the best way to utilizing knowledge initially dispersed among all the people is at least one of the main problems of economic policy – or of designing an efficient economic system.
  <br />人们在制定计划时所依据的知识通过各种方式传递给他们，这对于解释经济过程的任何理论来说都是至关重要的问题，什么是最好的方式来应用知识这个问题，最初分散在所有人当中，并且至少是一个政治经济，或者是设计一个最有效率的经济系统的主要问题之一。
  <br />*- The Use of Knowledge in Society, Friedrich A. Hayek, 1945*

